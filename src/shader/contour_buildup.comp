#version 450

#ifndef LOCAL_SIZE_X 
#define LOCAL_SIZE_X 256
#endif 

layout (local_size_x = LOCAL_SIZE_X) in;

struct AtomInformation
{
	vec3  position;
	float radius;
	uint  startCircleIdx;
	uint  neighborNumber;
	uint  gridHash;
};

struct CircleIntersection 
{
	vec3 center;
	float radius;
	uint atomId;
	uint neighboorAtomId;
	uint startProbeIdx;
	uint probeNb;
};

struct ProbePosition
{
	vec3 position;
	uint atomIndex;
};

layout (std140, binding = 0) readonly buffer AtomPositions
{ 
	uint atomNumber;
	AtomInformation atomsInformation[];
};

layout (std140, binding = 1) buffer Circles
{ 
	uint circleNb;
	CircleIntersection circles[];
};

layout (std140, binding = 2) writeonly buffer CirclesProbes
{ 
	uint probesNb;
	ProbePosition probes[];
};

layout(location = 0) uniform int   uMaxNeighborsNb;
layout(location = 1) uniform float uProbeRadius;

const float Pif     = 3.14159265358979;
const float TWO_PIf = 6.28318530717958;
const uint MaxTempProbeNb = 256;

struct Angle {
	float start;
	float end;
};

struct KIndex {
	uint start;
	uint end;
};

// https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/
vec4 quatFromAxis(float angle, vec3 axis) 
{
	const float halfAngle = angle / 2.;
	return vec4(
		axis.x * sin(halfAngle),
		axis.y * sin(halfAngle),
		axis.z * sin(halfAngle),
		cos(halfAngle)
	);
}

vec4 quat_conj(vec4 q)
{ 
  return vec4(-q.x, -q.y, -q.z, q.w); 
}

vec4 quatMult(vec4 q1, vec4 q2)
{ 
  vec4 qr;
  qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);
  qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);
  qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);
  qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);
  return qr;
}

vec3 quatMult(vec4 q, vec3 v)
{
	vec4 qr_conj = quat_conj(q);
	vec4 q_pos = vec4(v.x, v.y, v.z, 0);
	
	vec4 q_tmp = quatMult(q, q_pos);
	q = quatMult(q_tmp, qr_conj);
	
	return vec3(q.x, q.y, q.z);
}

vec3 computeIntersectionDirection( vec3 circleCenter, vec3 arcCenter )
{
	const float vjvk  = dot( circleCenter, arcCenter );
	const float denom = dot( circleCenter, circleCenter ) * dot( arcCenter, arcCenter ) - vjvk * vjvk;

	const float leftVec  = dot( circleCenter, circleCenter - arcCenter ) * dot( arcCenter, arcCenter );
	const float rightVec = dot( arcCenter - circleCenter, arcCenter ) * dot( circleCenter, circleCenter );

	return ( circleCenter * leftVec / denom ) + ( arcCenter * rightVec / denom );
};

void swap(inout vec3 x1, inout vec3 x2) 
{
	vec3 temp = x1;
	x1 = x2;
	x2 = temp;
}

void main() 
{
	uint circleId = uint(dot(gl_GlobalInvocationID, vec3(1, gl_NumWorkGroups.x, gl_NumWorkGroups.y * gl_NumWorkGroups.x)));
	if (circleId >= circleNb) return;

	CircleIntersection currentCircle = circles[circleId];
	if (currentCircle.atomId == 0 && currentCircle.neighboorAtomId == 0) return;
	
	AtomInformation ithAtom = atomsInformation[currentCircle.atomId];
	// if(ithAtom.neighborNumber == 0) return;

	float ithExtendedRadius = ithAtom.radius + uProbeRadius;
	AtomInformation jthAtom = atomsInformation[currentCircle.neighboorAtomId];

	const vec3 vJ = currentCircle.center;

	// Compute axes of local coordinate system
	vec3 xAxis = cross( vJ, vec3( 0., 1., 0. ) );
	if ( abs( dot( xAxis, xAxis ) ) < 1e-4 )
	{
		xAxis = cross( vJ, vec3( 1., 0., 0. ) );
	}

	xAxis	   = normalize( xAxis );
	vec3 yAxis = cross( xAxis, vJ );
	yAxis	   = normalize( yAxis );

	uint arcNb = 1;
	Angle arcAngles[64];
	arcAngles[0] = Angle(0, TWO_PIf);
	KIndex kIndices[64];
	kIndices[0] = KIndex(0, 0);

	const uint baseCircleCoordinates = atomsInformation[currentCircle.atomId].startCircleIdx;
	const uint maxCoordinates = baseCircleCoordinates + atomsInformation[ currentCircle.atomId ].neighborNumber;
	for(uint k = baseCircleCoordinates; k < maxCoordinates; k++) 
	{
		if ( circleId == k ) continue;

		CircleIntersection kThCircle = circles[k];
		AtomInformation kThAtom = atomsInformation[kThCircle.neighboorAtomId];
		const vec3 intersectionDirection = computeIntersectionDirection( currentCircle.center, kThCircle.center );
		if ( length( intersectionDirection ) > ithExtendedRadius ) continue;

		vec3 rkCrossRj = cross( kThCircle.center, currentCircle.center );
		float root	   = sqrt( ( ithExtendedRadius * ithExtendedRadius - dot( intersectionDirection, intersectionDirection ) ) / dot( rkCrossRj, rkCrossRj ) );
		vec3 x1 = intersectionDirection + rkCrossRj * root;
		vec3 x2 = intersectionDirection - rkCrossRj * root;

		if ( dot( kThCircle.center, ( kThAtom.position - ithAtom.position ) ) < 0. )
		{
			swap( x1, x2 );
		}

		currentCircle.radius = distance( x1, currentCircle.center );

		// transform x1 and x2 to small circle coordinate system
		float xX1 = dot( x1 - currentCircle.center, xAxis );
		float yX1 = dot( x1 - currentCircle.center, yAxis );

		float xX2 = dot( x2 - currentCircle.center, xAxis );
		float yX2 = dot( x2 - currentCircle.center, yAxis );

		float angleX1 = atan( yX1, xX1 );
		float angleX2 = atan( yX2, xX2 );

		// limit angles to 0..2*PI
		if ( angleX1 > TWO_PIf )
		{
			angleX1 = mod( angleX1, TWO_PIf );
			angleX2 = mod( angleX2, TWO_PIf );
		}

		// angle of x2 has to be larger than angle of x1 (add 2 PI)
		if ( angleX2 < angleX1 )
		{
			angleX2 += TWO_PIf;
		}

		// make all angles positive (add 2 PI)
		if ( angleX1 < 0. )
		{
			angleX1 += TWO_PIf;
			angleX2 += TWO_PIf;
		}
		
		uint tempArcNb = 0;
		Angle tempArcAngles[16];
		KIndex tempKIndices[16];
		for (int a = 0; a < arcNb; a++) 
		{
			const Angle angle = arcAngles[a];
			const KIndex index = kIndices[a];

			if ( angleX1 < angle.start )
			{
				// case (1) & (10)
				if ( ( angle.start - angleX1 ) > ( angleX2 - angleX1 ) )
				{
					if ( ( ( angle.start - angleX1 ) + ( angle.end - angle.start ) ) > TWO_PIf )
					{
						if ( ( ( angle.start - angleX1 ) + ( angle.end - angle.start ) )
								< ( TWO_PIf + angleX2 - angleX1 ) )
						{
							// case (10)
							arcAngles[ a ].start = angleX1;
							kIndices[ a ].start	 = kThCircle.neighboorAtomId;

							arcAngles[ a ].end = mod( angle.end, TWO_PIf );

							// second angle check
							if ( arcAngles[ a ].end < arcAngles[ a ].start )
								arcAngles[ a ].end += TWO_PIf;
						}
						else
						{
							arcAngles[ a ].start  = angleX1;
							arcAngles[ a ].end	  = angleX2;
							kIndices[ a ] = KIndex( kThCircle.neighboorAtomId, kThCircle.neighboorAtomId );

							// second angle check
							if ( arcAngles[ a ].end < arcAngles[ a ].start )
								arcAngles[ a ].end += TWO_PIf;
						}
					}
					else
					{
						// case (1)
						for(int t = a; t < arcNb - 1; t++) 
						{
							arcAngles[t] = arcAngles[t + 1];
							kIndices[t]  = kIndices[t + 1];
						}
						arcAngles[arcNb - 1] = Angle(0, 0);
						kIndices[arcNb - 1]  = KIndex(0, 0);
						a--;
						arcNb--;
					}
				}
				else
				{
					if ( ( ( angle.start - angleX1 ) + ( angle.end - angle.start ) )
							> ( angleX2 - angleX1 ) )
					{
						// case (5)
						arcAngles[ a ].end = mod( angleX2, TWO_PIf );
						kIndices[ a ].end  = kThCircle.neighboorAtomId;

						// second angle check
						if ( arcAngles[ a ].end < arcAngles[ a ].start )
							arcAngles[ a ].end += TWO_PIf;

						if ( ( ( angle.start - angleX1 ) + ( angle.end - angle.start) ) > TWO_PIf )
						{
							// case (6)
							tempArcAngles[tempArcNb] = Angle( angleX1, mod( angle.end, TWO_PIf ) );
							tempKIndices[tempArcNb] = KIndex( kThCircle.neighboorAtomId, index.end );
							

							// second angle check
							if ( tempArcAngles[tempArcNb].end < tempArcAngles[tempArcNb].start )
								tempArcAngles[tempArcNb].end += TWO_PIf;
							tempArcNb++;
						}
					}
				} // case (4): Do nothing!
			}
			else
			{ // angleX1 > s
				// case (2) & (9)
				if ( ( angleX1 - angle.start ) > ( angle.end - angle.start) )
				{
					if ( ( ( angleX1 - angle.start ) + ( angleX2 - angleX1 ) ) > TWO_PIf )
					{
						if ( ( ( angleX1 - angle.start ) + ( angleX2 - angleX1 ) )
								< ( TWO_PIf + angle.end - angle.start ) )
						{
							// case (9)
							arcAngles[ a ].end = mod( angleX2, TWO_PIf );
							kIndices[ a ].end  = kThCircle.neighboorAtomId;

							// second angle check
							if ( arcAngles[ a ].end < arcAngles[ a ].start )
								arcAngles[ a ].end += TWO_PIf;
						}
					}
					else
					{
						// case (2)
						for(int t = a; t < arcNb - 1; t++) 
						{
							arcAngles[t] = arcAngles[t + 1];
							kIndices[t]  = kIndices[t + 1];
						}

						arcAngles[arcNb - 1] = Angle(0, 0);
						kIndices[arcNb - 1]  = KIndex(0, 0);
						a--;
						arcNb--;
					}
				}
				else
				{
					if ( ( ( angleX1 - angle.start ) + ( angleX2 - angleX1 ) )
							> ( angle.end - angle.start ) )
					{
						// case (7)
						arcAngles[ a ].start = angleX1;
						kIndices[ a ].start	 = kThCircle.neighboorAtomId;

						// second angle check
						arcAngles[ a ].end = mod( arcAngles[ a ].end, TWO_PIf );
						if ( arcAngles[ a ].end < arcAngles[ a ].start )
							arcAngles[ a ].end += TWO_PIf;

						if ( ( ( angleX1 - angle.start ) + ( angleX2 - angleX1 ) ) > TWO_PIf )
						{
							// case (8)
							tempArcAngles[tempArcNb] = Angle(angle.start, mod( angleX2, TWO_PIf ) );
							tempKIndices[tempArcNb] = KIndex( index.start, kThCircle.neighboorAtomId );

							// second angle check
							if ( tempArcAngles[tempArcNb].end < tempArcAngles[tempArcNb].start)
								tempArcAngles[tempArcNb].end += TWO_PIf;
							tempArcNb++;
						}
					}
					else
					{
						// case (3)
						arcAngles[ a ] = Angle( angleX1, angleX2 );
						kIndices[ a ]  = KIndex( kThCircle.neighboorAtomId, kThCircle.neighboorAtomId );

						// second angle check
						if ( arcAngles[ a ].end < arcAngles[ a ].start )
							arcAngles[ a ].end += TWO_PIf;
					}
				}
			}
		}
		
		// add new angles from temporary array to angle array
		for ( uint aCnt = 0; aCnt < tempArcNb; aCnt++ )
		{
			arcAngles[arcNb + aCnt] = tempArcAngles[aCnt];
			kIndices[arcNb + aCnt] = tempKIndices[aCnt];
		}

		arcNb += tempArcNb;
		tempArcNb = 0;
	}

	// merge arcs if arc with angle 0 and arc with angle 2*PI exist
	int idx0   = -1;
	int idx2pi = -1;
	for ( int aCnt = 0; aCnt < arcNb; aCnt++ )
	{
		if ( abs( arcAngles[ aCnt ].start ) < 1e-4f )
		{
			idx0 = aCnt;
		}
		else if ( abs( arcAngles[ aCnt ].end - TWO_PIf ) < 1e-4f )
		{
			idx2pi = aCnt;
		}
	}

	if ( idx0 >= 0 && idx2pi >= 0 )
	{
		arcAngles[ idx0 ].start = arcAngles[ idx2pi ].start;
		kIndices[ idx0 ].start  = kIndices[ idx2pi ].start;

		// second angle check
		arcAngles[ idx0 ].end = mod( arcAngles[ idx0 ].end, TWO_PIf );
		if ( arcAngles[ idx0 ].end < arcAngles[ idx0 ].start )
			arcAngles[ idx0 ].end += TWO_PIf;

		for(int t = idx2pi; t < arcNb - 1; t++)
		{
			arcAngles[t] = arcAngles[t + 1];
			kIndices[t]  = kIndices[t + 1];
		}

		arcNb--;
	}

	const vec3 worldSpaceCircleCenter = ithAtom.position + currentCircle.center;
	const vec3 torusAxis = normalize( currentCircle.center );

	ProbePosition tempProbes[MaxTempProbeNb];
	uint probeNb = 0;
	
	for ( int aCnt = 0; aCnt < arcNb; aCnt++ )
	{
		vec4 rotQuat = quatFromAxis( -arcAngles[ aCnt ].start, torusAxis);
		vec3 circleDirection = quatMult( rotQuat, xAxis ) * currentCircle.radius;
		if ( currentCircle.neighboorAtomId < kIndices[ aCnt ].start)
		{
			tempProbes[probeNb] = ProbePosition ( 
				( ithAtom.position + currentCircle.center ) + circleDirection, 
				kIndices[ aCnt ].start 
			);

			probeNb++;
			if(probeNb == min(MaxTempProbeNb, uMaxNeighborsNb))
				break;
		}

		rotQuat = quatFromAxis( -arcAngles[ aCnt ].end, torusAxis );
		circleDirection = quatMult( rotQuat, xAxis ) * currentCircle.radius;
		if ( currentCircle.neighboorAtomId < kIndices[ aCnt ].end )
		{
			tempProbes[probeNb] = ProbePosition ( 
				( ithAtom.position + currentCircle.center ) + circleDirection, 
				kIndices[ aCnt ].end 
			);

			probeNb++;
			if(probeNb == min(MaxTempProbeNb, uMaxNeighborsNb))
				break;
		}
	}
	
	probeNb = min(probeNb, uMaxNeighborsNb);
	circles[circleId].probeNb = probeNb;
	
	if(probeNb > 0) 
	{
		const uint currentProbeStartIdx = atomicAdd(probesNb, probeNb);
		circles[circleId].startProbeIdx = currentProbeStartIdx;
		for(int t = 0; t < probeNb; t++)
		{
			probes[currentProbeStartIdx + t] = tempProbes[t];
		}
	}
	else {
		circles[circleId].startProbeIdx = 0;
	}
}