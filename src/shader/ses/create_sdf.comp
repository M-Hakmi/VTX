#version 450

#define FLT_MAX 3.402823466e+38

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// Uniforms.
uniform vec3	uGridAtomWorldOrigin;
uniform vec3	uGridSESWorldOrigin;
uniform uvec3	uGridAtomSize;
uniform uvec3	uGridSESSize;
uniform vec3	uGridAtomCellSize;
uniform vec3	uGridSESCellSize;
uniform uint	uGridAtomCellCount;
uniform float	uProbeRadius;
uniform float	uVoxelSize;

// Data struct.
struct AtomGridDataSortedStruct
{
	uint first;
	uint count;
};

struct SESGridDataStruct
{
	float sdf;
	int	  nearestAtom;
};

// SSBO.
// Input.
layout (std430, binding = 0) readonly buffer AtomGridData
{ 
	AtomGridDataSortedStruct[] atomGridData;
};

layout (std140, binding = 1) readonly buffer AtomIndex
{ 
	uint[] atomIndex;
};

layout (std140, binding = 2) readonly buffer AtomPosition
{ 
	vec3[] atomPosition;
};

layout (std140, binding = 3) readonly buffer AtomVdwRadius
{ 
	float[] atomVdwRadius;
};

// Output.
layout (std430, binding = 4) writeonly buffer SESGridData
{
	SESGridDataStruct[] sesGridData;
};

// Grid functions.
uvec3 gridPosition( vec3 p_worldPosition, vec3 p_worldOrigin, vec3 p_cellSize )
{	
	return uvec3( floor( ( p_worldPosition - p_worldOrigin ) / p_cellSize) );
}

uvec3 gridPosition( uint p_hash, uvec3 p_size )
{
	uint z = p_hash / ( p_size.x * p_size.y );
	uint r = p_hash % ( p_size.x * p_size.y );
	return uvec3( r % p_size.x , r / p_size.x, z );
}

vec3 worldPosition( uvec3 p_gridPosition, vec3 p_worldOrigin, vec3 p_cellSize )
{
	return p_worldOrigin +  ( ( vec3( p_gridPosition ) + 0.5f ) * p_cellSize );
}

vec3 worldPosition( uint p_hash, uvec3 p_size, vec3 p_worldOrigin, vec3 p_cellSize )
{ 
	return worldPosition( gridPosition( p_hash, p_size ), p_worldOrigin, p_cellSize );
}

uint gridHash( uvec3 p_gridPosition, uvec3 p_size )
{
	return ( p_gridPosition.z * p_size.x * p_size.y ) + ( p_gridPosition.y * p_size.x ) + p_gridPosition.x;
}

uint gridHash( vec3 p_worldPosition, uvec3 p_size, vec3 p_worldOrigin, vec3 p_cellSize )
{
	return gridHash( gridPosition( p_worldPosition, p_worldOrigin, p_cellSize ), p_size );
}

void main()
{
	// Get corresponding ses grid data.
	uvec3 sesGridPosition = gl_GlobalInvocationID;
	uint sesGridHash = gridHash( sesGridPosition, uGridSESSize );
	
	// Get corresponding acceleration grid data.
	vec3 sesGridCellWorldPosition = worldPosition( sesGridPosition, uGridSESWorldOrigin, uGridSESCellSize);
	uvec3 atomGridPosition = gridPosition( sesGridCellWorldPosition, uGridAtomWorldOrigin, uGridAtomCellSize);

	// Loop over the cells to visit.
	float minDistance = FLT_MAX;
	
	for ( int ox = -1; ox <= 1; ++ox )
	{
		for ( int oy = -1; oy <= 1; ++oy )
		{		
			for ( int oz = -1; oz <= 1; ++oz )
			{	
				vec3 offset = vec3( ox, oy, oz );
				uvec3 gridPositionToVisit = uvec3( atomGridPosition + offset );	
				uint hashToVisit = gridHash( gridPositionToVisit, uGridAtomSize );					
				
				if ( hashToVisit >= uGridAtomCellCount )
				{				
					continue;
				}	
				
				uint first = atomGridData[ hashToVisit ].first;
				uint count = atomGridData[ hashToVisit ].count;
				
				// Compute SDF.
				for ( uint i = first; i < first + count; ++i )
				{		
					uint index = atomIndex[i];					
					float d = distance( atomPosition[ index ], sesGridCellWorldPosition );
					
					// Inside.
					if ( d < uVoxelSize )
					{
						sesGridData[sesGridHash].sdf = -uVoxelSize;	
						sesGridData[sesGridHash].nearestAtom = -1;						
						// Don't need to loop over other cells.
						return;
					}
					// Boundary.
					else
					{					
						d -= ( uProbeRadius + atomVdwRadius[index] );
						if ( d < 0.f )
						{
							sesGridData[sesGridHash].sdf = -uVoxelSize;
							if ( d < minDistance )
							{
								minDistance	= d;
								sesGridData[sesGridHash].nearestAtom = int(index);
							}
						}						
					}
				}
			}
		}
	}
}