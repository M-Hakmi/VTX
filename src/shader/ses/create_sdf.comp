#version 450

#ifndef LOCAL_SIZE_X 
#define LOCAL_SIZE_X 256
#endif 

#ifndef LOCAL_SIZE_Y 
#define LOCAL_SIZE_Y 1
#endif

#ifndef LOCAL_SIZE_Z 
#define LOCAL_SIZE_Z 1
#endif 

layout (local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y, local_size_z = LOCAL_SIZE_Z) in;

// Uniforms.
uniform vec3	uGridAtomWorldOrigin;
uniform vec3	uGridSESWorldOrigin;
uniform ivec3	uGridAtomSize;
uniform ivec3	uGridSESSize;
uniform vec3	uGridAtomCellSize;
uniform vec3	uGridSESCellSize;
uniform ivec3	uCellsToVisitCount;
uniform float	uProbeRadius;
uniform float	uVoxelSize;

// Data struct.
struct AtomGridDataSortedStruct
{
	int first;
	int count;
};

struct SESGridDataStruct
{
	float sdf;
	int	  nearestAtom;
};

// SSBO.
// Input.
layout (std140, binding = 0) readonly buffer AtomGridData
{ 
	AtomGridDataSortedStruct[] atomGridData;
};

layout (std140, binding = 1) readonly buffer AtomIndex
{ 
	uint[] atomIndex;
};

layout (std140, binding = 2) readonly buffer AtomPosition
{ 
	vec3[] atomPosition;
};

layout (std140, binding = 3) readonly buffer AtomVdwRadius
{ 
	float[] atomVdwRadius;
};

// Output.
layout (std430, binding = 4) writeonly buffer SESGridData
{
	SESGridDataStruct[] sesGridData;
};

// Grid functions.
ivec3 gridPosition( vec3 p_worldPosition, vec3 p_worldOrigin, vec3 p_cellSize )
{	
	return ivec3( int( floor( ( p_worldPosition.x - p_worldOrigin.x ) / p_cellSize.x ) ),
				  int( floor( ( p_worldPosition.y - p_worldOrigin.y ) / p_cellSize.y ) ),
				  int( floor( ( p_worldPosition.z - p_worldOrigin.z ) / p_cellSize.z ) ) );
}

ivec3 gridPosition( uint p_hash, ivec3 p_size )
{
	uint x = p_hash / ( p_size.y * p_size.z );
	uint r = p_hash % ( p_size.y * p_size.z );
	return ivec3( x, r / p_size.z, r % p_size.z );
}

vec3 worldPosition( ivec3 p_gridPosition, vec3 p_worldOrigin, vec3 p_cellSize )
{
	return p_worldOrigin + ( vec3( p_gridPosition ) + 0.5f ) * p_cellSize;
}

vec3 worldPosition( uint p_hash, ivec3 p_size, vec3 p_worldOrigin, vec3 p_cellSize )
{ 
	return worldPosition( gridPosition( p_hash, p_size ), p_worldOrigin, p_cellSize );
}

uint gridHash( ivec3 p_gridPosition, ivec3 p_size )
{
	return ( p_gridPosition.x * p_size.y * p_size.z ) + ( p_gridPosition.y * p_size.z ) + p_gridPosition.z;
}

uint gridHash( vec3 p_worldPosition, ivec3 p_size, vec3 p_worldOrigin, vec3 p_cellSize )
{
	return gridHash( gridPosition( p_worldPosition, p_worldOrigin, p_cellSize ), p_size );
}

void main()
{
	// Get corresponding ses grid data.
	ivec3 sesGridPosition = ivec3( gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, gl_GlobalInvocationID.z );
	uint sesGridHash = gridHash( sesGridPosition, uGridSESSize );
	
	//SESGridDataStruct gridData = sesGridData[ sesGridHash ];

	// Get corresponding acceleration grid data.
	vec3 sesGridCellWorldPosition = worldPosition( sesGridPosition, uGridSESWorldOrigin, uGridSESSize );
	ivec3 atomGridPosition = gridPosition( sesGridCellWorldPosition, uGridAtomWorldOrigin, uGridAtomSize);

	// Loop over the cells to visit.
	float minDistance = 1000000;
	bool found	= false;

	for ( int ox = -uCellsToVisitCount.x; ox <= uCellsToVisitCount.x && !found; ++ox )
	{
		for ( int oy = -uCellsToVisitCount.y; oy <= uCellsToVisitCount.y && !found; ++oy )
		{
			for ( int oz = -uCellsToVisitCount.z; oz <= uCellsToVisitCount.z && !found; ++oz )
			{
				ivec3 offset = ivec3( ox, oy, oz );
				ivec3 gridPositionToVisit = atomGridPosition + offset;

				if ( gridPositionToVisit.x < 0 || gridPositionToVisit.y < 0
					|| gridPositionToVisit.z < 0 || gridPositionToVisit.x >= uGridAtomSize.x
					|| gridPositionToVisit.y >= uGridAtomSize.y
					|| gridPositionToVisit.z >= uGridAtomSize.z )
				{
					continue;
				}
				
				uint hashToVisit = gridHash( gridPositionToVisit, uGridAtomSize );
				uint first = atomGridData[ hashToVisit ].first;
				uint count = atomGridData[ hashToVisit ].count;
				// Compute SDF.
				for ( uint i = first; i < first + count; ++i )
				{				
					uint index = atomIndex[i];
					float d = distance( atomPosition[ index ], sesGridCellWorldPosition );

					// Inside.
					if ( d < uVoxelSize )
					{
						sesGridData[sesGridHash].sdf = -uVoxelSize;	
						sesGridData[sesGridHash].nearestAtom = -1;
						found = true;
						// Don't need to loop over other cells.
						break;
					}
					// Boundary.
					else
					{					
						d -= ( uProbeRadius + atomVdwRadius[index] );
						if ( d < 0.f )
						{
							//sesGridDataBoundary.insert( sesGridHash );
							sesGridData[sesGridHash].sdf = -uVoxelSize;
							if ( d < minDistance )
							{
								minDistance	= d;
								sesGridData[sesGridHash].nearestAtom = int(index);
							}
						}						
					}
				}
			}
		}
	}
}