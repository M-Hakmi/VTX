#version 450

#define FLT_MAX 3.402823466e+38

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// Uniforms.
uniform vec3	uGridAtomWorldOrigin;
uniform vec3	uGridSESWorldOrigin;
uniform ivec3	uGridAtomSize;
uniform ivec3	uGridSESSize;
uniform vec3	uGridAtomCellSize;
uniform vec3	uGridSESCellSize;
uniform uint	uGridAtomCellCount;
uniform ivec3	uCellsToVisitCount;
uniform float	uProbeRadius;
uniform float	uVoxelSize;

// Data struct.
struct AtomGridDataSortedStruct
{
	int first;
	int count;
};

struct SESGridDataStruct
{
	float sdf;
	int	  nearestAtom;
};

// SSBO.
// Input.
layout (std140, binding = 0) readonly buffer AtomGridData
{ 
	AtomGridDataSortedStruct[] atomGridData;
};

layout (std140, binding = 1) readonly buffer AtomIndex
{ 
	uint[] atomIndex;
};

layout (std140, binding = 2) readonly buffer AtomPosition
{ 
	vec3[] atomPosition;
};

layout (std140, binding = 3) readonly buffer AtomVdwRadius
{ 
	float[] atomVdwRadius;
};

// Output.
layout (std430, binding = 4) writeonly buffer SESGridData
{
	SESGridDataStruct[] sesGridData;
};

// Grid functions.
ivec3 gridPosition( vec3 p_worldPosition, vec3 p_worldOrigin, vec3 p_cellSize )
{	
	ivec3 gridPos = ivec3(floor(( p_worldPosition - p_worldOrigin ) / p_cellSize));

	/*
	gridPos.x = int( floor( ( p_worldPosition.x - p_worldOrigin.x ) / p_cellSize.x ) );
	gridPos.y = int( floor( ( p_worldPosition.y - p_worldOrigin.y ) / p_cellSize.y ) );
	gridPos.z = int( floor( ( p_worldPosition.z - p_worldOrigin.z ) / p_cellSize.z ) );
	*/
	
	return gridPos;
}

ivec3 gridPosition( uint p_hash, ivec3 p_size )
{
	uint z = p_hash / ( p_size.x * p_size.y );
	uint r = p_hash % ( p_size.x * p_size.y );
	return ivec3( r % p_size.x , r / p_size.x, z);
}

vec3 worldPosition( ivec3 p_gridPosition, vec3 p_worldOrigin, vec3 p_cellSize )
{
	vec3 position = p_worldOrigin;
	position +=  ( vec3( p_gridPosition ) + 0.5f ) * p_cellSize;
	return position;
}

vec3 worldPosition( uint p_hash, ivec3 p_size, vec3 p_worldOrigin, vec3 p_cellSize )
{ 
	return worldPosition( gridPosition( p_hash, p_size ), p_worldOrigin, p_cellSize );
}

uint gridHash( ivec3 p_gridPosition, ivec3 p_size )
{
	return ( p_gridPosition.z * p_size.x * p_size.y ) + ( p_gridPosition.y * p_size.x ) + p_gridPosition.x;
}

uint gridHash( vec3 p_worldPosition, ivec3 p_size, vec3 p_worldOrigin, vec3 p_cellSize )
{
	return gridHash( gridPosition( p_worldPosition, p_worldOrigin, p_cellSize ), p_size );
}

void main()
{
	// Get corresponding ses grid data.
	ivec3 sesGridPosition = ivec3( gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, gl_GlobalInvocationID.z );
	uint sesGridHash = gridHash( sesGridPosition, uGridSESSize );
	
	// Get corresponding acceleration grid data.
	vec3 sesGridCellWorldPosition = worldPosition( sesGridPosition, uGridSESWorldOrigin, uGridSESCellSize);
	ivec3 atomGridPosition = gridPosition( sesGridCellWorldPosition, uGridAtomWorldOrigin, uGridAtomCellSize);

	// Loop over the cells to visit.
	float minDistance = FLT_MAX;
	bool found	= false;
	
	for ( int ox = -uCellsToVisitCount.x; ox <= uCellsToVisitCount.x && !found; ++ox )
	{
		for ( int oy = -uCellsToVisitCount.y; oy <= uCellsToVisitCount.y && !found; ++oy )
		{		
			for ( int oz = -uCellsToVisitCount.z; oz <= uCellsToVisitCount.z && !found; ++oz )
			{	
				vec3 offset = vec3( ox, oy, oz );
				ivec3 gridPositionToVisit = ivec3( atomGridPosition + offset );	
				uint hashToVisit = gridHash( gridPositionToVisit, uGridAtomSize );	
				
				if ( hashToVisit >= uGridAtomCellCount )
				{
					continue;
				}	

				uint first = atomGridData[ hashToVisit ].first;
				uint count = atomGridData[ hashToVisit ].count;

				////////////////////////////////////////////
				sesGridData[sesGridHash].sdf = hashToVisit;
				sesGridData[sesGridHash].nearestAtom = int(sesGridHash);
				return;
				////////////////////////////////////////////
				
				// Compute SDF.
				for ( uint i = first; i < first + count; ++i )
				{		
					uint index = atomIndex[i];					
					float d = distance( atomPosition[ index ], sesGridCellWorldPosition );
					
					sesGridData[sesGridHash].sdf = d;
					
					// Inside.
					if ( d < uVoxelSize )
					{
						sesGridData[sesGridHash].sdf = -uVoxelSize;	
						sesGridData[sesGridHash].nearestAtom = -1;
						found = true;
						// Don't need to loop over other cells.
						break;
					}
					// Boundary.
					else
					{					
						d -= ( uProbeRadius + atomVdwRadius[index] );
						if ( d < 0.f )
						{
							//sesGridDataBoundary.insert( sesGridHash );
							sesGridData[sesGridHash].sdf = -uVoxelSize;
							if ( d < minDistance )
							{
								minDistance	= d;
								sesGridData[sesGridHash].nearestAtom = int(index);
							}
						}						
					}
				}
			}
		}
	}
}