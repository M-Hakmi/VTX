#version 450

#ifndef LOCAL_SIZE_X 
#define LOCAL_SIZE_X 256
#endif 

#ifndef LOCAL_SIZE_Y 
#define LOCAL_SIZE_Y 1
#endif 

layout (local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y) in;

struct CellInfo
{
	int start;
	int end;
};

// Inputs
layout (std140, binding = 0) readonly buffer Uniforms 
{
	uint  uElementNb;
	ivec3 uGridSize;
	vec3  uCellSize;
	vec3  uWorldOrigin;
};

layout (std140, binding = 1) readonly buffer Spheres
{ 
	vec4 spheres[];
};

// Outputs
layout (std430, binding = 2) writeonly buffer Keys
{ 
	uint hashes[];
};

layout (std430, binding = 3) writeonly buffer Indices
{ 
	uint indices[];
};

ivec3 computeGridPosition(const vec3 position) 
{
    ivec3 gridPos;
    gridPos.x = int(floor((position.x - uWorldOrigin.x) / uCellSize.x));
    gridPos.y = int(floor((position.y - uWorldOrigin.y) / uCellSize.y));
    gridPos.z = int(floor((position.z - uWorldOrigin.z) / uCellSize.z));
    return gridPos;
}

uint computeGridHash(ivec3 gridPosition) 
{
	gridPosition.x = gridPosition.x & ( uGridSize.x - 1 ); // wrap grid, assumes size is power of 2
	gridPosition.y = gridPosition.y & ( uGridSize.y - 1 );
	gridPosition.z = gridPosition.z & ( uGridSize.z - 1 );
	return ( ( gridPosition.z * uGridSize.y ) * uGridSize.x ) + ( gridPosition.y * uGridSize.x ) + gridPosition.x;
}

shared uint sharedData[ LOCAL_SIZE_X + 1 ];
void main() 
{
    const uvec3 GlobalSize = gl_WorkGroupSize * gl_NumWorkGroups;
	const int id = int( dot( gl_GlobalInvocationID, vec3(1, GlobalSize.x, GlobalSize.y * GlobalSize.x ) ) );
	if( id < uElementNb )
	{
		const vec4 data = spheres[id];
		hashes[id] = computeGridHash(computeGridPosition(data.xyz));
	}
	else
	{
		hashes[id] = uint(~0); 
	}

	indices[id] = id;
}
