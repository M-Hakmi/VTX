#version 450

#ifndef LOCAL_SIZE_X 
#define LOCAL_SIZE_X 256
#endif 

#ifndef LOCAL_SIZE_Y 
#define LOCAL_SIZE_Y 1
#endif 

layout (local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y) in;

layout(std140, binding = 0) readonly buffer Uniforms
{
	uint  uAtomNb;
	uint  uMaxNeighborsNb;
	float uProbeRadius;
	uint  uTorusNb;
	uint  uProbeNb;
};

layout (std140, binding = 1) readonly restrict buffer Atoms
{ 
	vec4 atoms[];
};

layout (std430, binding = 2) readonly buffer Neighbors
{ 
	uint atomsNeighbors[];
};

layout (std430, binding = 3) restrict readonly buffer NeighborsCount
{ 
	uint neighborsCount[];
};

layout (std140, binding = 4) restrict buffer Circles
{ 
	vec4 circles[];
};

layout (std430, binding = 5) readonly buffer CirclesVisibilityStatus
{
	uint circlesVisibilityStatus[]; // 0: invisible, 1: visible
};

layout (std430, binding = 6) readonly buffer CirclesVisibilityStatusScan
{
	uint visibilityScan[];
};

layout (std140, binding = 7) readonly buffer Arcs
{
	vec4 arcs[];
};

layout (std430, binding = 8) readonly buffer ArcCount
{
	uint arcCount[];
};

layout (std430, binding = 9) readonly buffer ArcCountScan
{
	uint arcCountScan[];
};

layout (std140, binding = 10) writeonly buffer ProbesData
{
	vec4 probesData[];
};

layout (std140, binding = 11) writeonly buffer TorusesData
{
	vec4 torusesData[];
};

const float Pif     = 3.141592;
const float TWO_PIf = 6.283185;

// https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/
vec4 quatFromAxis(float angle, vec3 axis) 
{
	const float halfAngle = angle / 2.;
	return vec4(
		axis.x * sin(halfAngle),
		axis.y * sin(halfAngle),
		axis.z * sin(halfAngle),
		cos(halfAngle)
	);
}

// Based on GLM implementation
vec3 quatMult(vec4 quat, vec3 point)
{
	const vec3 quatVector = vec3(quat.x, quat.y, quat.z);
	const vec3 uv = cross(quatVector, point);
	const vec3 uuv = cross(quatVector, uv);

	return point + ((uv * quat.w) + uuv) * 2;
}

vec3 computeProbPosition ( vec3 atomPos, vec3 direction, float startAngle, float radius )
{
	vec4 rotQuat = quatFromAxis( -startAngle, normalize( direction ) );
	vec3 xAxis   = cross( direction, vec3( 0., 1., 0. ) );
	if ( abs( dot( xAxis, xAxis ) ) < 1e-4f )
	{
		xAxis = cross( direction, vec3( 1., 0., 0. ) );
	}
	xAxis = normalize( xAxis );

	const vec3 circledirection = quatMult( rotQuat, xAxis ) * ( radius );
	return ( atomPos + direction ) + circledirection;
}

void main() 
{
	const uint atomId = gl_WorkGroupID.y * gl_WorkGroupSize.y + gl_LocalInvocationID.y;
	const uint jId	  = gl_WorkGroupID.x * gl_WorkGroupSize.x + gl_LocalInvocationID.x;

	if ( atomId >= uAtomNb ) return;
	if ( jId >= uMaxNeighborsNb) return;
	
	const uint neighborCount = neighborsCount[atomId];
	if( jId >= neighborCount ) return;

	const vec4 ithAtom = atoms[atomId];
	const uint currentCircleId = atomId * uMaxNeighborsNb + jId;

	const uint j	   = atomsNeighbors[currentCircleId];
	const vec4 jthAtom = atoms[j];

	const uint probeNb			 = arcCount[currentCircleId];
	const uint numPreviousProbes = arcCountScan[currentCircleId];
	const uint startProbeId		 = atomId * uMaxNeighborsNb * uMaxNeighborsNb + jId * uMaxNeighborsNb;
	for( uint probeId = 0; probeId < probeNb; probeId++ ) 
	{
		const vec4 probePosition = arcs[startProbeId + probeId];
		const uint globalProbeId = numPreviousProbes + probeId;
		
		const uint kIdx = uint( floor( probePosition.w));
		const vec4 kthAtom = atoms[kIdx];

		probesData[uProbeNb * 0 + globalProbeId /* Position */ ] = vec4( probePosition.xyz,				  uProbeRadius );
		probesData[uProbeNb * 1 + globalProbeId /* Vec 1    */ ] = vec4( ithAtom.xyz - probePosition.xyz, 1.0f);
		probesData[uProbeNb * 2 + globalProbeId /* Vec 2    */ ] = vec4( jthAtom.xyz - probePosition.xyz, 1.0f);
		probesData[uProbeNb * 3 + globalProbeId /* Vec 3    */ ] = vec4( kthAtom.xyz - probePosition.xyz, uProbeRadius * uProbeRadius);
	}

	if(circlesVisibilityStatus[currentCircleId] > 0)
	{
		const uint torusId = visibilityScan[currentCircleId];

		vec4 circle  = circles[currentCircleId];

		const vec3 torusAxis   = normalize(circle.xyz);
		const vec3 torusCenter = circle.xyz + ithAtom.xyz;
		const vec3 ortho	   = normalize( cross( torusAxis, vec3( 0., 0., 1. ) ) );

		const vec3 p = torusCenter + ( ortho * circle.w );
		const vec3 x = normalize( p - ithAtom.xyz ) * ithAtom.w;

		const vec3 d = ( distance( p, ithAtom.xyz )/ ( distance( p, jthAtom.xyz ) + distance( p, ithAtom.xyz) ) ) * ( jthAtom.xyz - ithAtom.xyz );
		
		const float vSphereRadius = length(((p - ithAtom.xyz) / distance(p, ithAtom.xyz)) * ithAtom.w - d);
		const vec3  vSphereCenter = ( d + ithAtom.xyz ) - torusCenter;

		torusesData[uTorusNb * 0 + torusId /* Torus Position */] = vec4( torusCenter, circle.w );
		torusesData[uTorusNb * 1 + torusId /* Torus Axis     */] = vec4( torusAxis, uProbeRadius );
		torusesData[uTorusNb * 2 + torusId /* Torus Vs       */] = vec4( vSphereCenter, vSphereRadius );
	}
}