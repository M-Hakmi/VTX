#version 450

#ifndef LOCAL_SIZE_X 
#define LOCAL_SIZE_X 256
#endif 

#ifndef LOCAL_SIZE_Y 
#define LOCAL_SIZE_Y 1
#endif 

layout (local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y) in;

struct CellInfo
{
	int start;
	int end;
};

// Inputs
layout (std140, binding = 0) readonly buffer Uniforms 
{
	uint uElementNb;
};

layout (std140, binding = 1) readonly buffer Spheres
{ 
	vec4 spheres[];
};

layout (std430, binding = 2) readonly buffer Hashes
{ 
	uint hashes[];
};

layout (std430, binding = 3) readonly buffer Indices
{ 
	uint indices[];
};

// Outputs
layout (std140, binding = 4) writeonly buffer SortedSpheres
{ 
	vec4 sortedSpheres[];
};

layout (std140, binding = 5) writeonly buffer AccelerationStructure
{
	CellInfo cellsInformation[];
};

shared uint sharedData[ LOCAL_SIZE_X + 1 ];
void main() 
{
    const uvec3 GlobalSize = gl_WorkGroupSize * gl_NumWorkGroups;
	const int id = int( dot( gl_GlobalInvocationID, vec3(1, GlobalSize.x, GlobalSize.y * GlobalSize.x ) ) );
	if( id >= uElementNb ) return;

	const uint currentHash = hashes[id];
	sharedData[ gl_LocalInvocationIndex + 1 ] = currentHash;
	if(id > 0 && gl_LocalInvocationIndex == 0)
	{
		const uint firstWorkGroupHash = hashes[id-1];
		sharedData[ 0 ] = firstWorkGroupHash;
	}
	
	memoryBarrierShared();
	barrier();

	if( id == 0 || currentHash != sharedData[ gl_LocalInvocationIndex ] )
	{
		cellsInformation[ currentHash ].start = id;

		if( id > 0 )
		{
			cellsInformation[ sharedData[ gl_LocalInvocationIndex ] ].end = id - 1;
		}
	}

	if( id == uElementNb - 1 )
	{
		cellsInformation[ currentHash ].end = id;
	}

	uint sortedIndex = indices[id];
	vec4 pos = spheres[sortedIndex];
	sortedSpheres[ id ] = pos;
}
