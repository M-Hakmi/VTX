#version 450

#ifndef LOCAL_SIZE_X 
#define LOCAL_SIZE_X 256
#endif 

#ifndef LOCAL_SIZE_Y 
#define LOCAL_SIZE_Y 1
#endif 

layout (local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y) in;

struct CellInfo
{
	int start;
	int end;
};

layout(std140, binding = 0) readonly buffer Uniforms
{
	uint  uAtomNb;
	uint  uMaxNeighborsNb;
	float uProbeRadius;
	ivec3 uGridSize;
	vec3  uCellSize;
	vec3  uWorldOrigin;
	float uMaxVdwRadius;
};

layout (std140, binding = 1) buffer AtomPositions
{ 
	vec4 atoms[];
};

layout (std430, binding = 2) buffer Neighbors
{ 
	uint atomsNeighbors[];
};

layout (std430, binding = 3) buffer NeighborsCount
{ 
	uint neighborsCount[];
};

layout (std140, binding = 4) writeonly buffer Circles
{ 
	vec4 circles[];
};

layout (std140, binding = 5) readonly buffer AccelerationStructure
{
	CellInfo cells[];
};

ivec3 computeGridPosition(const vec3 position) 
{
    ivec3 gridPos;
    gridPos.x = int(floor((position.x - uWorldOrigin.x) / uCellSize.x));
    gridPos.y = int(floor((position.y - uWorldOrigin.y) / uCellSize.y));
    gridPos.z = int(floor((position.z - uWorldOrigin.z) / uCellSize.z));
    return gridPos;
}

uint computeGridHash(ivec3 gridPosition) 
{
	gridPosition.x = gridPosition.x & ( uGridSize.x - 1 ); // wrap grid, assumes size is power of 2
	gridPosition.y = gridPosition.y & ( uGridSize.y - 1 );
	gridPosition.z = gridPosition.z & ( uGridSize.z - 1 );
	return ( ( gridPosition.z * uGridSize.y ) * uGridSize.x ) + ( gridPosition.y * uGridSize.x ) + gridPosition.x;
}

uint findNeighborsInCell ( const uint atomId, const vec4 atom, const CellInfo currentCell, uint neighborNumber )
{
	if ( currentCell.start < 0 )
		return 0;

	uint count = 0;
	for ( uint j = currentCell.start; j <= currentCell.end; j++ )
	{
		if ( atomId == j )
			continue;

		const vec4  atomJ				 = atoms[ j ];
		const float maxVdwDistance		 = atom.w + atomJ.w + 2. * uProbeRadius;
		vec3		iToJ				 = atomJ.xyz - atom.xyz;
		const float distanceBetweenAtoms = length( iToJ );

		if ( distanceBetweenAtoms > maxVdwDistance )
			continue;

		if( ( neighborNumber + count) >= uMaxNeighborsNb ) return count;

		atomsNeighbors[atomId * uMaxNeighborsNb + neighborNumber + count] = j;

		const float ithExtendedRadius = atom.w + uProbeRadius;
		const float jthExtendedRadius = atomJ.w + uProbeRadius;
		float distanceToCircleCenter = ( ( ithExtendedRadius * ithExtendedRadius ) + distanceBetweenAtoms * distanceBetweenAtoms
										- ( jthExtendedRadius * jthExtendedRadius ) );
		distanceToCircleCenter = distanceToCircleCenter / ( 2.f * distanceBetweenAtoms * distanceBetweenAtoms );

		iToJ *= distanceToCircleCenter;

		const float radius = sqrt( ithExtendedRadius * ithExtendedRadius - dot( iToJ, iToJ ) );
		const vec4 newCircle = vec4(iToJ, radius);
		circles[atomId * uMaxNeighborsNb + neighborNumber + count] = newCircle;
		
		count++;
	}

	return count;
}

void main() 
{
    const uvec3 GlobalSize = gl_WorkGroupSize * gl_NumWorkGroups;
	int id = int(dot(gl_GlobalInvocationID, vec3(1, GlobalSize.x, GlobalSize.y * GlobalSize.x)));
	if(id >= uAtomNb) return;

	vec4 currentAtom = atoms[id];
	const float gridCellRange = currentAtom.w + uMaxVdwRadius + 2. * uProbeRadius;

	const ivec3 cellsInRange = max( ivec3( ceil( gridCellRange / uCellSize ) ), ivec3(2));
	const ivec3 gridPos = computeGridPosition( currentAtom.xyz );

	ivec3 start = max(gridPos - cellsInRange, ivec3(0));
	ivec3 end = min(gridPos + cellsInRange, uGridSize);

	uint neighborNumber = 0;
	for ( int z = start.z; z <= end.z; z++ )
	{
		for ( int y = start.y; y <= end.y; y++ )
		{
			for ( int x = start.x; x <= end.x; x++ )
			{
				const ivec3 gridPos = ivec3( x, y, z );
				const uint gridHash = computeGridHash( gridPos );
				const CellInfo currentCell = cells[ gridHash ];

				neighborNumber += findNeighborsInCell( id, currentAtom, currentCell, neighborNumber );
			}
		}
	}
	
	neighborsCount[id] = neighborNumber;
}
